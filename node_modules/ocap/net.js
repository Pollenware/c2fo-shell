var Config  = require( 'config/net.js' ).Config,
    extend  = require( 'third-party/extend.js' ).extend,
    MCat    = require( 'message-catalog/ocap/net.js' ).MCat,
    request = require( 'third-party/request.js' );

exports.Net = Net;

function Net( userAgent, emitter ) {

  var self = this;

  if ( ! Config.isSecure )
    self.protocol = 'http://';
  else
    self.protocol = 'https://';
 
  self.get = function ( route, responseCallback, hostname, cookie ) {

    if ( self.isDebugging )
      emitter.emit( 'debugMessage', ' GET ' + self.protocol + hostname + Config.hostSuffix + Config.hostServices + route );

    request( 
      {
        'method' : 'get',
        'uri'    : self.protocol + hostname + Config.hostSuffix + Config.hostServices + route,
        'headers': {
          'Referer'    : self.protocol + hostname + Config.hostSuffix,
          'Cookie'     : cookie,
          'User-Agent' : userAgent || ( MCat.agentDefault + ' ' + process.argv[1].split( '/' ).pop()  )
         }
      },

      function ( error, response, body ) {
        if ( !error && response.statusCode == 200 ) {
          var onTick = function () {
            try {
              var ocap;
              ocap = JSON.parse( body );
              if ( ocap.payload.response.error ) {
                emitter.emit( 'failOCAPresponse', ocap.payload.response.error_msg );
                return;
              }
              else {
                responseCallback( response );
                return;
              }
            }
            catch( e ) {
              emitter.emit( 'failJSONParse', e );
              return;
            }
          }
          process.nextTick(onTick)
        }
        else {
          function onTick() {
            try {
              emitter.emit( 'failOCAPresponse', response && response.statusCode );
            }
            catch( e ) {
              emitter.emit( 'failOCAPfail', e );
              return;
            }
          }
          process.nextTick(onTick)
        }
      }
    );
  };

  self.isDebugging = false;

  self.post = function ( payload, route, responseCallback, hostname, cookie ) {

    if ( self.isDebugging ) {

      var tempPayload = {};

      extend( true, tempPayload, payload );
      tempPayload.password = MCat.passwordMask;

      emitter.emit( 'debugMessage', ' ' + JSON.stringify( tempPayload )  );
      emitter.emit( 'debugMessage', ' POST ' + self.protocol + hostname + Config.hostSuffix + Config.hostServices + route );

    }

    request(
      {
        'method' : 'post',
        'uri'    : self.protocol + hostname + Config.hostSuffix + Config.hostServices + route,
        'headers': {
          'Content-Type' : 'application/x-www-form-urlencoded',
          'Cookie'       : cookie,
          'Referer'      : self.protocol + hostname + Config.hostSuffix
        },
        'body'   : JSON.stringify( payload )
      },

      function ( error, response, body ) {
        if ( !error && response.statusCode == 200 ) {
          if ( response.body ) {
            var onTick = function () {
              try {
                var ocap = JSON.parse( body );
                if ( ocap.payload.response.error ) {
                  emitter.emit( 'failOCAPresponse', ocap.payload.response.error_msg );
                  return;
                }
                else {
                  responseCallback( response );
                  return;
                }
              }
              catch( e ) {
                emitter.emit( 'failJSONParse', e );
                return;
              }
            }
            process.nextTick( onTick );
          }
          else {
            return;
          }
        }
        else {
          function onTick() {
            try {
              emitter.emit( 'failOCAPresponse', response && response.statusCode );
            }
            catch( e ) {
              emitter.emit( 'failOCAPfail', e );
              return;
            }
          }
          process.nextTick(onTick)
        }
      }
    );
  };

}
